// Даны входная строка и шаблон(паттерн).
// Реализуйте сопоставление строки с регулярным выражением по заданному шаблону с поддержкой символов . и *.
//
// Примечание:
// - Символ . соответствует любому отдельному символу, * - ноль или более предыдущего элемента.
// - Соответствие должно охватывать всю входную строку (не частично).
// - Строка может быть пустой или содержать только строчные буквы a-z.
// - Шаблон(паттерн) может быть пустым или содержать только строчные буквы a-z, а также символы . и *.

object Task9 {
  def solution(s: String, p: String): Boolean = {
    // Создаем двумерный массив для хранения результатов
    val dp = Array.fill(s.length + 1, p.length + 1)(false)

    // Пустая строка соответствует пустому шаблону
    dp(0)(0) = true

    // Обрабатываем случай, когда шаблон содержит символы *, которые могут соответствовать пустой строке
    for (j <- 1 to p.length) {
      if (p(j - 1) == '*') {
        dp(0)(j) = dp(0)(j - 2) // * может соответствовать пустой строке
      }
    }

    // Заполняем таблицу dp
    for (i <- 1 to s.length) {
      for (j <- 1 to p.length) {
        if (p(j - 1) == s(i - 1) || p(j - 1) == '.') {
          dp(i)(j) = dp(i - 1)(j - 1) // Символы совпадают
        } else if (p(j - 1) == '*') {
          dp(i)(j) = dp(i)(j - 2) || // * соответствует 0 символам
            (dp(i - 1)(j) && (s(i - 1) == p(j - 2) || p(j - 2) == '.')) // * соответствует 1 или более символам
        }
      }
    }

    dp(s.length)(p.length) // Возвращаем результат
  }

  println(s"Task 9 = ${solution("aa", "a")}")
  // Task 9 = false

  println(s"Task 9 = ${solution("aa", "a*")}")
  // Task 9 = true

  println(s"Task 9 = ${solution("ab", ".*")}")
  // Task 9 = true

  println(s"Task 9 = ${solution("aab", "c*a*b")}")
  // Task 9 = true

  println(s"Task 9 = ${solution("mississippi", "mis*is*p*.")}")
  // Task 9 = false

}
