import scala.concurrent.Await
// Допустим, что владелец кафе попросил нас написать функцию для подсчета суммы заказа на основании меню заведения. 1)
// Меню заведения договорились хранить как список List[(String, Int)], где строкой задается название блюда,
// а целым значением - его стоймость. Наша функция должна принимать заказ клиента в виде списка названий блюд и выводить сумму заказа:
// def getPriceByOrder(order: List[String]): Int = ??? 2)
// Наше кафе разрослось, и теперь в нем более 100 блюд. Как мы можем ускорить поиск позиции в нашем меню?

val list = List(("суп", 100), ("салат", 200))

def getPriceByOrder(order: List[String]): Int = {

 val newList = list.toMap

 val resnmew = order.map(i => list.find(i == _._1).toList).flatten.map(_._2).sum
 val resnmew1 = order.flatMap(i => list.find(i == _._1).toList).map(_._2).sum

 val res = for {
   o <- order
   m <- list
   if(o == m._1)
 } yield m._2
  res.sum

}

getPriceByOrder(List(("суп"), ("салат")))

// Предположим, что в нашем проекте существуют два долгих вычисления,
// и в определенной функции мы должны по условию определить,
// какое вычисление использовать.
// Каким образом мы передадим эти вычисления в нашу функцию?

lazy val a1 = {
 Thread.sleep(10000)
 40
}

lazy val a2 = {
 Thread.sleep(10000)
 42
}

def eval(cond: Boolean, e1: Int, e2: Int) = {
 if (cond) e1 else e2
}

// Пусть у нас есть список целых чисел. Необходимо написать функцию,
// которая принимает этот список и возвращает список из четных элементов,
// чей модуль не превышает 1000, утроив каждый из этих элементов.

def check(nums: List[Int]): List[Int] = {
 nums.filter(i => i % 2 == 0 && i < 100).map(_ * 3)

 nums.collect {
  case n if n % 2 == 0 && n < 100 => n * 3
 }
}

// Пусть на вход функции подается список из пар элементов (List[(String, Int)]).
// Наша функция должна вернуть список строк, который формируется из элементов исходного,
// у которых строка начинается с заглавной буквы.
// При этом каждый элемент выходного списка (строка) должна иметь вид:
// "This is Строка with count Число",
// где Строка и Число берутся из элемента исходного списка.

def check (list: List[(String, Int)]): List[String] = {
 list.collect {
  case i if i._1.headOption.exists(_.isUpper) => s"This is ${i._1} with ${i._2} Число"
 }
}
println(check(List(("str1", 1), ("Str2", 2))))

// Пусть у нас на вход функции поступает Seq[Future[String]].
// Получить Future[(Seq[String], Seq[Throwable]) - результат агрегации выполненных Future и  исключений









